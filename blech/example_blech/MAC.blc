module 
const CAP: float64 = 4096.0

struct  State
    var m1: float64;
    var m2: float64;
    var acc: float64;
    //var acc:[2]float64;
end

// (MacOp.ms -> readonly) (MacOp.a -> is potentially written)
// sharing specification tells us that this procedure implements
// all memory access to MacOp.a and to the substructure MacOp.ms.acc of MacOp.ms in single thread.
// Note: This activity does not declare any return type. We call this "void" but unlike C we do not have void type in the language.
//  anything that is in shared  right hand side is like an expression that is typed checked
// Share specification i.e., paramameter 'shares' 'expression' not general expression. This expressio
activity MacOp(ms: State)(a shares ms: float64)//a shares ms.acc[*]:float64
    repeat
        a = ms.m1 * ms.m2 + ms.acc;
        await true
    end
end

// Note: This activity does not declare any return type. We call this "void" but unlike C we do not have void type in the language.
activity Accumulate (arr: [2]float64)(s:State)
    cobegin weak
        repeat 
            s.m1 = arr[0]; s.m2 = arr[1];
            await true
        end
    with weak
        // Resolve scheduling order here.
        // write access s.acc.wr is sequentially ordered after the read s.acc.rd.
        // This procedure call is concurrent should be scheduled before the watchdog thread 'await s.acc > CAP' Write-before-read Policy.
        run MacOp (s) (s.acc) 
    with
        // Will be scheduled after the 'Activity MacOp (s) (s.acc)'.
        await s.acc > CAP  
    end
end
