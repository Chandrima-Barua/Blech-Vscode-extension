activity P (x1 :bool, x2 :bool) (y1 shares x2 :bool, y2 :bool)
	var local_var1:bool 
	var local_var2:bool
	cobegin
		local_var1 = x1
		y1 = local_var1
	with
		local_var2 = x2
		y2 = local_var2
	end
	await true
end

activity Q (x1 :bool, x2 :bool) (y1 :bool, y2 shares x1 :bool)
	var local_var1:bool 
	var local_var2:bool
	cobegin
		local_var1 = x1
		y1 = local_var1
	with
		local_var2 = x2
		y2 = local_var2
	end
	await true
end

@[EntryPoint]
activity main () ()
	var in1: bool
	var in2: bool
	var out1: bool
	var out2: bool
	
	run P (in1,out1)(out1,out2)
	run Q (out2,in2)(out1,out2)
end


// activity feedback1 (x1: bool, x2: bool) (y1 shares x2: bool,y2: bool)
//     var val1:bool
//     var val2:bool
//     var val3: bool
//     var val4: bool
//     cobegin
//         val1 = x1 // x1 is read
//         //val2 = x2 //This represent a case(1) rd ---> wr (read before write) where x2 is read before written in a single thread. Adheres to Sharing Intefaces, if we assume policy for var type variables?
//         y1 = val1 // y1 is written 
//         //var val2:bool = x2 // x2 is read
//         //val2 = x2 //This represent a case(2) rd ---> wr (write before read) where x2 is written before read in a single thread. Adheres to Sharing Intefaces!
//         //val3 = true
//         val3 = y2
//         //y2 = false
//     with
//         //val2 = x2 // x2 is read
//         y2 = val2 // y2 is written  Think about it: it is a local variable but it's written and read concurrently is we assume Sharing Interfaces case(2)?
//         val4 = val3
//     end
//     await true
// end
// activity feedback2 (x1:bool, x2:bool) (y1 shares x1:bool, y2:bool)
//     var local_var1:bool 
//     var local_var2:bool
//     cobegin
//         cobegin
//             local_var1 = x1
//             y1 = local_var1 //Also we can see writing of y1 and reading of x2 in local_var2 in the program graph does not define any data-flow precedence because they are treated distinct by the previous causality checking but due to "shares" now they should not be concurrently accessed and that's why our analysis detects that and throws and error.
//         with
//             local_var2 = x2 //This will be scheduled before "y2 = local_var2" line no.34 because it is writing local_var2 while y2 is reading local_var2 and the previous causality analysis adds a data-flow edge between them.
//         end
//     with
//         //val2 = x2
//         y2 = local_var2
//     end
//     await true
// end

// activity feedback3 (x1:bool, x2:bool) (y1:bool, y2 shares x1:bool)
//     var local_var1:bool 
//     var local_var2:bool
//     cobegin
//         // cobegin
//         //     local_var1 = x1
//         //     y1 = local_var1
//         // with
//         //     local_var2 = x2
//         // end
//         local_var1 = x1
//         y1 = local_var1
//     with
//         local_var2 = x2
//         y2 = local_var2
//     end
//     await true
// end

// @[EntryPoint]
// activity main () ()
//     var in1: bool
//     var in2: bool
//     var out1: bool
//     var out2: bool

//     //This represent a normal procedure call (aliasing free, distinct parameters).
//     //run feedback (in1, in2) (out1, out2)

//     //This represent when x2 and y1 of activity feedback are mapped to the same location out1.
//     //run feedback1(in1,out1)(out1,out2) 
//     //This represent when x1 and y2 of activity feedback are mapped to the same location out2.
//     //run feedback(out2,in2)(out1,out2)

    
//     //run feedback3(out1,in2)(out1,out2) //This activity call check that the sharing is declared but not on the desired parameter therefore it throw error for using a "shares" keyword.
//     //run feedback3(out2, in2)(out1,out2)
//     run feedback2(in1,out1)(out1,out2)

// end